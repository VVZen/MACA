#include "Individual.h"
#define IMAGE_WIDTH 80
#define IMAGE_HEIGHT 60
#define GENE_SIZE 5

//-------------------------------------------------------
struct genetic_point {
    ofColor color;
    ofPoint pos;
};

//-------------------------------------------------------
Individual::Individual(){
    imageWidth = IMAGE_WIDTH;
    imageHeight = IMAGE_HEIGHT;
    geneSize = GENE_SIZE;
}
//-------------------------------------------------------
void Individual::setup(DNA _dna){
    dna = _dna;
    geneSize = dna.geneSize;
    numOfGenes = dna.numOfGenes;
    phenotype = getPhenotype(imageWidth, imageHeight);
}
//-------------------------------------------------------
void Individual::setup(int _numOfGenes){
    numOfGenes = _numOfGenes;
    dna.setup(numOfGenes, geneSize);
    phenotype = getPhenotype(imageWidth, imageHeight);
}
//-------------------------------------------------------
// This function turns the floats into an image made up
// of triangles of variable colors and locations
ofImage Individual::getPhenotype(int width, int height){

    ofFbo fbo;
    fbo.allocate(width, height, GL_RGB);
    fbo.begin();
    
    ofBackground(0);

    ofxDelaunay triangulation;
    vector <genetic_point> genetic_points;

    // cout << "adding points to delaunay" << endl;

    for (int i = 0; i < dna.genes.size(); i+=dna.geneSize){

        // color
        int red = ofMap(dna.genes.at(i), 0, 1, 0, 255);
        int green = ofMap(dna.genes.at(i+1), 0, 1, 0, 255);
        int blue = ofMap(dna.genes.at(i+2), 0, 1, 0, 255);
        //TODO: investigate why Theo does this thing
        // int alpha = ofMap(max(dna.genes.at(i+3)*dna.genes.at(i+4), 0.2f), 0, 1, 0, 255); // could just multiply by 255
        //int alpha = ofMap(dna.genes.at(i+3), 0, 1, 0, 255);
        // position
        ofPoint current_position = ofPoint(ofMap(dna.genes.at(i+3), 0, 1, 0, width), ofMap(dna.genes.at(i+4), 0, 1, 0, height));
        triangulation.addPoint(current_position);

        // since I know the number of genes in input but I don't know how many triangles
        // will be generated by delaunay, I now store position and color of each point 
        // in a custom data structure.
        // After computing delaunay I will use this info to find 
        // the closest genetic point for the given delanauy triangle
        // so that I know of which color I should paint it
        genetic_point current_gen_point;
        current_gen_point.pos = current_position;
        current_gen_point.color = ofColor(red, green, blue, 255);
        genetic_points.push_back(current_gen_point);
    }
    // cout << "computing delaunay" << endl;

    // compute delaunay of given points
    triangulation.triangulate();
    //ofSetColor(255);
    //triangulation.triangleMesh.drawWireframe();

    // cout << "num of genes            :      " << dna.genes.size() << endl;
    // cout << "num of points           :      " << dna.genes.size() * 2.0f / 7.0f  << endl;
    // cout << "num of triangles created:      " << triangulation.getNumTriangles() << endl;
    // cout << "num of genetic points created: " << genetic_points.size() << endl;

    for (int i = 0; i < triangulation.getNumTriangles(); i++){
        
        // get points for current triangle
        vector<ofPoint> tri_points = get_triangle_points(triangulation, i);

        // compute centroid
        ofPoint centroid;
        centroid.x = (tri_points.at(0).x + tri_points.at(1).x + tri_points.at(2).x) / 3;
        centroid.y = (tri_points.at(0).y + tri_points.at(1).y + tri_points.at(2).y) / 3;

        int genetic_point_index = 0;
        // for this delaunay triangle, find the closest genetic point
        // so that we can know which color it should be
        float min_distance = fbo.getWidth();

        
        // sort genetic points using lambda function that compute distance from centroid
        // see : https://www.youtube.com/watch?v=uk0Ytomv0wY 
        // and https://stackoverflow.com/questions/32634239/c-sort-vector-based-on-distance-to-external-point
        sort(begin(genetic_points), end(genetic_points), [centroid](const genetic_point& gp1, const genetic_point& gp2){
            return ofDist(centroid.x, centroid.y, gp1.pos.x, gp1.pos.y) < ofDist(centroid.x, centroid.y, gp2.pos.x, gp2.pos.y);
        });

        // for (int g = 0; g < genetic_points.size(); g++){
            
        //     genetic_point current_gen_point = genetic_points.at(g);

        //     float distance = ofDist(centroid.x, centroid.y, current_gen_point.pos.x, current_gen_point.pos.y);

        //     if (distance < min_distance){
        //         min_distance = distance;
        //         genetic_point_index = g;
        //     }
        // }

        ofColor color = genetic_points.at(genetic_point_index).color;
        ofSetColor(color);

        ofDrawTriangle(tri_points.at(0), tri_points.at(1), tri_points.at(2));
    }


    /* for (int i = 0; i < dna.genes.size(); i += geneSize){

        // color
        int red = ofMap(dna.genes[i], 0, 1, 0, 255);
        int green = ofMap(dna.genes[i+1], 0, 1, 0, 255);
        int blue = ofMap(dna.genes[i+2], 0, 1, 0, 255);
        int alpha = ofMap(max(dna.genes[i+3]*dna.genes[i+4], 0.2f), 0, 1, 0, 255); // could just multiply by 255
        ofSetColor(red, green, blue, alpha);

        // points positions
        triangulation.addPoint();

        // ofPoint anchor = ofPoint(ofMap(dna.genes[i+5], 0, 1, 0, width), ofMap(dna.genes[i+6], 0, 1, 0, height));
        // ofPoint offset1 = ofPoint(ofMap(dna.genes[i+7], 0, 1, -width/2, width/2), ofMap(dna.genes[i+8], 0, 1, -height/2, height/2));
        // ofPoint offset2 = ofPoint(ofMap(dna.genes[i+9], 0, 1, -width/2, width/2), ofMap(dna.genes[i+10], 0, 1, -height/2, height/2));
        // ofPoint offset3 = ofPoint(ofMap(dna.genes[i+11], 0, 1, -width/2, width/2), ofMap(dna.genes[i+12], 0, 1, -height/2, height/2));

        // ofDrawTriangle(offset1+anchor, offset2+anchor, offset3+anchor);
    } */

    fbo.end();

    ofPixels pixels;
    fbo.readToPixels(pixels);
    ofImage img;
    img.setFromPixels(pixels);
    return img;
}
//--------------------------------------------------------
// calculates fitness by subtracting the individual's image
// from the target image and summing up the pixel differences
void Individual::calcFitness (const ofImage &target) {

    ofPixels targetPixels = target.getPixels();
    ofPixels phenotypePixels = phenotype.getPixels();

    int totalAbsDiff = 0;
    int imageSize = target.getWidth()*target.getHeight()*3;

    for (int i=0; i<imageSize; i++){
            totalAbsDiff += abs(targetPixels[i]-phenotypePixels[i]);
    }
    fitness = (float)totalAbsDiff / (float)imageSize;
}

//--------------------------------------------------------------
// END OF GENETIC STUFF
//--------------------------------------------------------------
// custom function (by Theo) that takes a triangulation object and an index
// and returns the coordinates of the triangle we refer to
// (I modified it slightly so that it's more encapsulated)
vector <ofPoint> Individual::get_triangle_points(ofxDelaunay & triangulation, int i){

    int pA = triangulation.triangleMesh.getIndex(i*3);
    int pB = triangulation.triangleMesh.getIndex(i*3+1);
    int pC = triangulation.triangleMesh.getIndex(i*3+2);

    ofPoint pointA = triangulation.triangleMesh.getVertex(pA);
    ofPoint pointB = triangulation.triangleMesh.getVertex(pB);
    ofPoint pointC = triangulation.triangleMesh.getVertex(pC);

    vector <ofPoint> points;
    points.push_back(pointA);
    points.push_back(pointB);
    points.push_back(pointC);
    
    return points;
}
